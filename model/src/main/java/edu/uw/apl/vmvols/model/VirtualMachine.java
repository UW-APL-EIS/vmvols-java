package edu.uw.apl.vmvols.model;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import edu.uw.apl.vmvols.model.virtualbox.VDIDisk;
import edu.uw.apl.vmvols.model.virtualbox.VDIException;
import edu.uw.apl.vmvols.model.virtualbox.VBoxVM;
import edu.uw.apl.vmvols.model.vmware.VMDKDisk;
import edu.uw.apl.vmvols.model.vmware.VMDKException;
import edu.uw.apl.vmvols.model.vmware.VMwareVM;

/**
 * @author Stuart Maclean
 *
 * A base class for all (two!) the virtual machine managers whose disk
 * formats we support: VirtualBox and VMWare (host-based, not vmfs,
 * etc) .
 *
 * Example: for a virtual machine (perhaps a VirtualBox one) in dir
 * 'M' with a single virtual hard disk, this code gets us access to
 * the disk as a 'device file', i.e. whole disk (not any partition)
 *
 <code>
 VirtualMachine vm = VirtualMachine.create( "/path/to/M" );
 List<VirtualDisk> vds = vm.getActiveDisks();
 VirtualDisk vd = vds.get(0);
 </code>
 *
 * Note that this is a 'pure-Java' implementation.  We have pure-Java
 * file format parsers for VirtualBox and VMware (host-based products
 * like Workstation, not any vmfs/ESX-originating disks).  There is no
 * JNI portion binding to any VM engine libraries.  In fact to use
 * this Java API, the VM software need not even be present.  All we
 * need are the .vdi/.vmdk files themselves.
 *
 * @see virtualbox.VBoxVM
 * @see vmware.VMwareVM
 */

abstract public class VirtualMachine {

	/**
	 * This should be the sole api method for generating
	 * VirtualMachines and accessing disks.  The user should never
	 * have to call any VBoxVM or VMwareVM methods directly.  Update
	 * as and when we accommodate more VM types (ha!)
	 */
	static public VirtualMachine create( File f ) throws IOException {
		if( VBoxVM.isVBoxVM( f ) )
			return new VBoxVM( f );
		if( VMwareVM.isVMwareVM( f ) )
			return new VMwareVM( f );
		File parent = f.getParentFile();
		if( VBoxVM.isVBoxVM( parent ) )
			return new VBoxVM( parent );
		if( VMwareVM.isVMwareVM( parent ) )
			return new VMwareVM( parent );

		if( f.isDirectory() )
			// Neither VM type we know about AND not a file, bail...
			return null;

		/*
		  If neither the supplied file nor its parent directory can be
		  classed as a true vm root dir, but we know we have a regular
		  file, we treat the supplied file as a standalone (orphan?)
		  vdi/vmdk as generated by e.g. packer (will be alongside an
		  .ovf file) or e.g. vagrant (will be alongside a .box file).
		  We then build a 'dummy' vm around that one file.  The VM
		  obviously has just one hard disk, and no possible Snapshots.
		*/
		VirtualDisk vd = null;
		String name = f.getName();
		if( false ) {
		} else if( name.endsWith( VDIDisk.FILESUFFIX ) ) {
			try {
				vd = VDIDisk.readFrom( f );
				int last = name.length() - VDIDisk.FILESUFFIX.length(); 
				name = name.substring( 0, last - 1 );
			} catch( VDIException e ) {
				// LOOK: log?
			}
		} else if( name.endsWith( VMDKDisk.FILESUFFIX ) ) {
			try {
				vd = VMDKDisk.readFrom( f );
				int last = name.length() - VMDKDisk.FILESUFFIX.length(); 
				name = name.substring( 0, last - 1 );
			} catch( VMDKException e ) {
				// LOOK: log?
			}
		}
		if( vd == null )
			return null;
		final List<VirtualDisk> vds = new ArrayList<VirtualDisk>();
		vds.add( vd );
		final String namef = name;
		return new VirtualMachine() {
			@Override
			public String getName() {
				return namef;
			}
			
			@Override
			public List<VirtualDisk> getBaseDisks() {
				return vds;
			}
			
			@Override
			public List<VirtualDisk> getActiveDisks() {
				return getBaseDisks();
			}
		};
	}

	abstract public String getName();

	abstract public List<VirtualDisk> getBaseDisks();
	abstract public List<VirtualDisk> getActiveDisks();
}

// eof
